/* vim: ft=lex
 * A lexcial analyzer for very simple expressions. Designed to work with a 
 * Bison parser. 
 *
 * $Author: kbuckner $
 * $Date: 2021-09-27 11:38:16-06 $
 * $Id: simple.lpp,v 1.3 2021-09-27 11:38:16-06 kbuckner Exp kbuckner $
 * 
 * $Log: simple.lpp,v $
 * Revision 1.3  2021-09-27 11:38:16-06  kbuckner
 * *** empty log message ***
 *
 * Revision 1.2  2020-09-28 14:10:51-06  kbuckner
 * Cleaned up a little
 *
 * Revision 1.1  2017-10-04 13:20:53-06  kbuckner
 * Finally working version
 * 
 */
%{

#include<iostream>
#include<iomanip>
#include<string>
#include"nodes.hpp"
  // this next file is generated by bison
#include"simple.tab.hpp"

using std::string;
using std::endl;
using std::cerr;
using std::cout;


/*
 * trivial yyerror() function. Could  do fancy stuff but for now...
 * BUT YOU MUST SUPPLY ONE!
 */
void yyerror(const char *string)
{
  cerr << string << endl;
  return;
}
%}

%option outfile="simple_lex.cpp"
%option noyywrap
%option yylineno

SPACE [ \t]




%%
	/*
	* the operators
	*/
\(	{ 
	return LPAREN;
	}
\^	{
	return EXP;
	}
\)	{ 
	return RPAREN;
	}
\+	{ 
	return PLUS;
	}
-	{ 
	return MINUS;
	}
\*	{ 
	return TIMES;
	}
\/	{
	return DIV;
	}
{SPACE}+ {
        //yycolumn+=yyleng;
	}
	/*
	 * The reserved words
	 */
[0-9]+	{
          yylval.ttype=new Node;
          yylval.ttype->setval(atoi(yytext));
  	  //print("identifier",yytext);
	  return NUM;
	}
	/*
	 * Comments C++ single line
	 */
\/\/[^\n]*\n {
	  //cout << yyline << ": Comment" << endl;
	  //yycolumn=1;
	}
	/*
	 * 
	 */
[\n]	{ 
        return NL; // YOU WILL NOT use newlines in your program
        // nothing else to do here, using yylineno
	}
.	{
        // the "did not match" rule, being explicit.
        cerr << "something unmatched: " << yytext << endl;
        }
%%
